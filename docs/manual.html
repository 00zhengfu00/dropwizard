<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Manual | Dropwizard</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <script src="js/prettify.js"></script>
    <script src="js/lang-yaml.js"></script>

    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/prettify.css">
    <link rel="stylesheet" href="css/additional.css">

<body onload="prettyPrint();">

<div class="topbar">
    <div class="topbar-inner">
        <div class="container-fluid">
            <a class="brand" href="index.html">Dropwizard</a>
            <ul class="nav">
                <li><a href="index.html">Home</a></li>
                <li><a href="getting-started.html">Getting Started</a></li>
                <li class="active"><a href="manual.html">Manual</a></li>
                <li><a href="https://groups.google.com/forum/?hl=en#!forum/dropwizard-user">Mailing List</a></li>
                <li><a href="https://github.com/codahale/dropwizard">Code</a></li>
            </ul>
        </div>
    </div>
</div>

<div class="container-fluid">
    <div class="sidebar">
        <div class="well">
            <h5>Dropwizard User’s Manual</h5>
            <ul>
                <li><a href="#organization">Organization</a></li>
                <li>
                    <a href="#services">Services</a>
                    <ul>
                        <li><a href="#configuration">Configuration</a></li>
                        <li><a href="#environments">Environments</a></li>
                        <li><a href="#health-checks">Health Checks</a></li>
                        <li><a href="#managed">Managed Objects</a></li>
                        <li><a href="#bundles">Bundles</a></li>
                        <li>
                            <a href="#commands">Commands</a>
                            <ul>
                                <li><a href="#configured-commands">Configured Commands</a></li>
                                <li><a href="#managed-commands">Managed Commands</a></li>
                            </ul>
                        </li>

                        <li><a href="#tasks">Tasks</a></li>
                        <li>
                            <a href="#logging">Logging</a>
                            <ul>
                                <li><a href="#console-logging">Console Logging</a></li>
                                <li><a href="#file-logging">File Logging</a></li>
                                <li><a href="#syslog-logging">Syslog Logging</a></li>
                            </ul>
                        </li>
                        <li><a href="#testing-services">Testing Services</a></li>
                        <li><a href="#banners">Banners</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#resources">Resources</a>
                    <ul>
                        <li><a href="#paths">Paths</a></li>
                        <li><a href="#methods">Methods</a></li>
                        <li><a href="#parameters">Parameters</a></li>
                        <li><a href="#request-entities">Request Entities</a></li>
                        <li><a href="#conneg">Media Types</a></li>
                        <li><a href="#responses">Responses</a></li>
                        <li><a href="#error-handling">Error Handling</a></li>
                        <li><a href="#uris">URIs</a></li>
                        <li><a href="#testing-resources">Testing</a></li>
                        <li><a href="#oauth">OAuth2</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#representations">Representations</a>
                    <ul>
                        <li><a href="#json">Basic JSON</a></li>
                        <li>
                            <a href="#advanced-json">Advanced JSON</a>
                            <ul>
                                <li><a href="#snakecase">snake_case</a></li>
                            </ul>
                        </li>
                        <li>
                            <a href="#validation">Validation</a>
                            <ul>
                                <li><a href="#advanced-validation">Advanced</a></li>
                            </ul>
                        </li>
                        <li><a href="#streaming">Streaming Output</a></li>
                        <li><a href="#testing-representations">Testing</a></li>
                        <li><a href="#custom-representations">Custom Representations</a></li>
                    </ul>
                </li>
                <li><a href="#running">Running Services</a></li>
                <li><a href="#production">In Production</a></li>
                <li><a href="#client">Dropwizard Client</a></li>
                <li><a href="#db">Dropwizard DB</a></li>
                <li><a href="#templates">Dropwizard Templates</a></li>
                <li><a href="#scala">Dropwizard &amp; Scala</a></li>

            </ul>
        </div>
    </div>

    <div class="content">
        <h1>Dropwizard User’s Manual</h1>

        <p>
            This goal of this document is to provide you with all the information required to
            build, organize, test, deploy, and maintain Dropwizard-based services.
        </p>

        <h2 id="organization">Organization</h2>

        <p>
            In general, we recommend you separate your projects into three Maven modules:
            <code><strong>project-api</strong></code>, <code><strong>project-client</strong></code>,
            and <code><strong>project-server</strong></code>. <code>project-api</code> should
            contain your <a href="#representations">representation classes</a>;
            <code>project-client</code> should use those classes and an HTTP client from
            <a href="#client"><code>dropwizard-client</code></a> to implement a full-fledged client
            for your service, and <code>project-server</code> should provide the actual service
            implementation, including <a href="#resources">resources</a>.
        </p>

        <p>Our services tend to look like this:</p>

        <dl>
            <dt><code><strong>com.example.myservice.api</strong></code></dt>
            <dd><a href="#representations">Representation</a> classes</dd>
            <dt><code><strong>com.example.myservice.cli</strong></code></dt>
            <dd>Service <a href="#commands">command</a> classes</dd>
            <dt><code><strong>com.example.myservice.client</strong></code></dt>
            <dd>Client implementation</dd>
            <dt><code><strong>com.example.myservice.core</strong></code></dt>
            <dd>Domain implementation</dd>
            <dt><code><strong>com.example.myservice.health</strong></code></dt>
            <dd><a href="#health-checks">Health check</a> classes</dd>
            <dt><code><strong>com.example.myservice.resources</strong></code></dt>
            <dd><a href="#resources">Resource</a> classes</dd>
            <dt><code><strong>com.example.myservice.MyService</strong></code></dt>
            <dd>The <a href="#services">service</a> class</dd>
            <dt><code><strong>com.example.myservice.MyServiceConfiguration</strong></code></dt>
            <dd>The <a href="#configuration">configuration</a> class</dd>
        </dl>

        <h2 id="services">Services</h2>

        <p>
            The main entry point into a Dropwizard service is, unsurprisingly, the
            <code>Service</code> class. Each <code>Service</code> has a <strong>name</strong>,
            which is mostly used to render the command-line interface. In the constructor of your
            <code>Service</code> you can add <a href="#bundles">bundles</a> and
            <a href="#commands">commands</a> to your service.
        </p>

        <h3 id="configuration">Configuration</h3>

        <p>
            Each <code>Service</code> subclass has a single type parameter: that of its matching
            <code>Configuration</code> subclass. These are usually at the root of your service’s
            main package. For example, your User service would have two classes:
            <code>UserServiceConfiguration</code>, extending <code>Configuration</code>,
            and <code>UserService</code>, extending
            <code>Service&lt;UserServiceConfiguration&gt;</code>.
        </p>

        <p>
            When your service runs a <a href="#configured-commands">configured command</a> like the
            <code>server</code> command, Dropwizard parses the provided YAML configuration file and
            builds an instance of your service’s configuration class by mapping YAML field names to
            object field names.
        </p>

        <p>
            In order to keep your configuration file and class manageable, we recommend grouping
            related configuration parameters into independent configuration classes.  If your
            service requires a set of configuration parameters in order to connect to a message
            queue, for example, we recommend that you create a new
            <code>MessageQueueConfiguration</code> class:
        </p>

        <pre class="prettyprint lang-java">
public class MessageQueueConfiguration {
    @NotEmpty
    private String host;

    @Min(1)
    @Max(65535)
    private int port = 5672;

    public String getHost() {
        return host;
    }

    public int getPort() {
        return port;
    }
}</pre>

        <p>
            Your main <code>Configuration</code> subclass can then include this as a member field:
        </p>

        <pre class="prettyprint lang-java">
public class ExampleServiceConfiguration extends Configuration {
    @NotNull
    private MessageQueueConfiguration messageQueue = new MessageQueueConfiguration();

    public MessageQueueConfiguration getMessageQueueConfiguration() {
        return messageQueue;
    }
}</pre>

        <p>
            Then, in your service’s YAML file, you can use a nested <code>messageQueue</code> field:
        </p>

        <pre class="prettyprint lang-yaml">
messageQueue:
  host: mq.example.com
  port: 5673</pre>

        <p>
            The <code>@NotNull</code>, <code>@NotEmpty</code>, <code>@Min</code>, and
            <code>@Max</code> annotations are part of Dropwizard’s
            <a href="#validation">validation</a> functionality. If your YAML configuration file’s
            <code>messageQueue.host</code> field was missing (or was a blank string), Dropwizard
            would refuse to start and would output an error message describing the issues.
        </p>

        <p>
            Once your service has parsed the YAML file and constructed its
            <code>Configuration</code> instance, Dropwizard then calls your <code>Service</code>
            subclass to initialize your service’s <code>Environment</code>.
        </p>

        <h3 id="environments">Environments</h3>

        <p>
            A Dropwizard <code>Environment</code> consists of all the
            <a href="#resources">resource classes</a>, servlets, filters,
            <a href="#health-checks">health checks</a>, Jersey providers,
            <a href="#managed">managed objects</a>, <a href="#tasks">tasks</a>, and Jersey
            properties which your service provides.
        </p>

        <p>
            Each <code>Service</code> subclass implements an <code>initialize</code> method. This
            is where you should be creating new resource instances, etc., and adding them to the
            given <code>Environment</code> class:
        </p>

        <pre class="prettyprint lang-java">
@Override
protected void initialize(ExampleConfiguration config,
                          Environment environment) {
    // encapsulate complicated setup logic in factories
    final ThingyFactory thingyFactory = new ThingyFactory(config.getThingyConfiguration());

    final Thingy thingy = thingyFactory.build();

    environment.addResource(new ThingyResource(thingy));
    environment.addHealthCheck(new ThingyHealthCheck(thingy));
}</pre>

        <p>
            It’s important to keep the <code>initialize</code> method clean, so if creating an
            instance of something is complicated, like the <code>Thingy</code> class above, extract
            that logic into a factory.
        </p>

        <h3 id="health-checks">Health Checks</h3>

        <p>
            A health check is a runtime test which you can use to verify your service’s behavior
            in its production environment. For example, you may want to ensure that your database
            client is connected to the database:
        </p>

        <pre class="prettyprint lang-java">
public class DatabaseHealthCheck extends HealthCheck {
    private final Database database;

    public DatabaseHealthCheck(Database database) {
        this.database = database;
    }

    @Override
    public String name() {
        return "database";
    }

    @Override
    public Result check() throws Exception {
        if (database.isConnected()) {
            return Result.healthy();
        } else {
            return Result.unhealthy("Cannot connect to " + database.getUrl());
        }
    }
}</pre>
        
        <p>
            You can then add this health check to your service’s environment:
        </p>

        <pre class="prettyprint lang-java">
environment.addHealthCheck(new DatabaseHealthCheck(database));</pre>

        <p>
            By sending a <code>GET</code> request to <code>/healthcheck</code> on the admin port you
            can run these tests and view the results:
        </p>

        <pre class="uglyprint">
$ curl http://dw.example.com:8081/healthcheck
* deadlocks: OK
* database: OK</pre>

        <p>
            If all health checks report success, a <code>200 OK</code> is returned. If any fail,
            a <code>500 Internal Server Error</code> is returned with the error messages and
            exception stack traces (if an exception was thrown).
        </p>

        <p>
            All Dropwizard services ship with the <code>deadlocks</code> health check installed by
            default, which uses Java 1.6's built-in thread deadlock detection to determine if any
            threads are deadlocked.
        </p>

        <h3 id="managed">Managed Objects</h3>

        <p>
            Most services involve objects which need to be started and stopped: thread pools,
            database connections, etc. Dropwizard provides the <code>Managed</code> interface for
            this. You can either have the class in question implement <code>Managed</code>’s
            <code>start()</code> and <code>stop()</code> methods, or write a wrapper class which
            does so. Adding a <code>Managed</code> instance to your service’s
            <code>Environment</code> ties that object’s lifecycle to that of the service’s HTTP
            server. Before the server starts, the <code>Managed</code>’s <code>start()</code> method
            is called. After the server has stopped (and after its graceful shutdown period) the
            <code>Managed</code>’s <code>stop()</code> method is called.
        </p>

        <p>
            For example, given a theoretical
            <a href="http://riak.basho.com" target="_blank">Riak</a> client which needs to be
            started and stopped:
        </p>

        <pre class="prettyprint lang-java">
public class RiakClientManager implements Managed {
    private final RiakClient client;

    public RiakClientManager(RiakClient client) {
        this.client = client;
    }

    @Override
    public void start() throws Exception {
        client.start();
    }

    @Override
    public void stop() throws Exception {
        client.stop();
    }
}</pre>

        <p>
            If <code>RiakClientManager#start()</code> throws an exception—e.g., an error connecting
            to the server—your service will not start and a full exception will be logged. If
            <code>RiakClientManager#stop()</code> throws an exception, the exception will be logged
            but your service will still be able to shut down.
        </p>

        <p>
            It should be noted that <code>Environment</code> has built-in constructors for
            <code>ExecutorService</code> and <code>ScheduledExecutorService</code> instances which
            are managed. See <code>Environment#managedExecutorService</code> and
            <code>Environment#managedScheduledExecutorService</code> for details.
        </p>

        <h3 id="bundles">Bundles</h3>

        <p>
            A Dropwizard bundle is a reusable group of functionality, used to define blocks of a
            service’s behavior. For example, <code>AssetBundle</code> provides a simple way to serve
            static assets from your service’s <code>src/main/resources/assets</code> directory as
            files available from <code>/assets/*</code> in your service.
        </p>

        <p>
            Some bundles require configuration parameters. The bundles implement
            <code>ConfiguredBundle</code> and will require your service’s <code>Configuration</code>
            subclass to implement a specific interface.
        </p>

        <h3 id="commands">Commands</h3>

        <p>
            Commands are basic actions which Dropwizard runs based on the arguments provided on the
            command line. The built-in <code>server</code> command, for example, spins up an HTTP
            server and runs your service. Each <code>Command</code> subclass has a name and a set
            of command line options which Dropwizard will use to parse the given command line
            arguments.
        </p>

        <h4 id="configured-commands">Configured Commands</h4>

        <p>
            Some commands require access to configuration parameters and should extend the
            <code>ConfiguredCommand</code> class, using your service’s <code>Configuration</code>
            class as its type parameter. Dropwizard will treat the first argument on the command
            line as the path to a YAML configuration file, parse and validate it, and provide your
            command with an instance of the configuration class.
        </p>

        <h4 id="managed-commands">Managed Commands</h4>

        <p>
            Managed commands further extend configured commands by creating a lifecycle process for
            your service’s <a href="#managed">managed objects</a>. All <code>Managed</code>
            instances registered with your service’s <code>Environment</code> will be started before
            your command is run, and will be stopped afterward.
        </p>
        
        <h3 id="tasks">Tasks</h3>

        <p>
            A <code>Task</code> is a run-time action your service provides access to on the
            administrative port via HTTP. All Dropwizard services start with the <code>gc</code>
            task, which explicitly triggers the JVM's garbage collection. (This is useful, for
            example, for running full garbage collections during off-peak times or while the given
            service is out of rotation.)
        </p>

        <p>
            Running a task can be done by sending a <code>POST</code> request to
            <code>/tasks/{task-name}</code> on the admin port. For example:
        </p>
        
        <pre class="uglyprint">
$ curl -X POST http://dw.example.com:8081/tasks/gc
Running GC...
Done!</pre>
        
        <h3 id="logging">Logging</h3>

        <p>
            Dropwizard uses <a href="http://logging.apache.org/log4j" target="_blank">Log4j</a> for
            its logging backend. It provides an
            <a href="http://www.slf4j.org/" target="_blank">slf4j</a> implementation, and even
            routes all <code>java.util.logging</code> usage through log4j.
        </p>

        <p>Dropwizard’s log format has a few specific goals:</p>

        <ul>
            <li>Be human readable.</li>
            <li>Be machine parsable.</li>
            <li>
                Be easy for sleepy ops folks to figure out why things are pear-shaped at 3:30AM
                using standard UNIXy tools like <code>tail</code> and <code>grep</code>.
            </li>
        </ul>

        <p>The logging output looks like this:</p>

    <pre class="uglyprint">
TRACE [2010-04-06 06:42:35,271] com.example.dw.Thing: Contemplating doing a thing.
DEBUG [2010-04-06 06:42:35,274] com.example.dw.Thing: About to do a thing.
INFO  [2010-04-06 06:42:35,274] com.example.dw.Thing: Doing a thing
WARN  [2010-04-06 06:42:35,275] com.example.dw.Thing: Doing a thing
ERROR [2010-04-06 06:42:35,275] com.example.dw.Thing: This may get ugly.
FATAL [2010-04-06 06:42:35,275] com.example.dw.Thing: The thing has gone horribly wrong.
! java.lang.RuntimeException: oh noes!
! at com.example.dw.Thing.run(Thing.java:16)
!</pre>

        <p>A few items of note:</p>

        <ul>
            <li>All timestamps are in UTC and ISO 8601 format.</li>
            <li>
                You can grep for messages of a specific level really easily:
                <code>tail -f dw.log | grep '^WARN'</code>
            </li>
            <li>
                You can grep for messages from a specific class or package really easily:
                <code>tail -f dw.log | grep 'com.example.dw.Thing'</code>
            </li>
            <li>
                You can even pull out full exception stack traces, plus the accompanying
                log message: <code>tail -f dw.log | grep -B 1 '^\!'</code>
            </li>
        </ul>

        <p>
            You can specify a default logger level and even override the levels of other loggers in
            your YAML configuration file:
        </p>

        <pre class="prettyprint lang-yaml">
# Logging settings.
logging:
  # The default level of all loggers. Can be OFF, FATAL, ERROR, WARN, INFO, DEBUG, TRACE, or ALL.
  level: INFO
  # Logger-specific levels.
  loggers:
    # Overrides the level of com.example.dw.Thing and sets it to DEBUG.
    "com.example.dw.Thing": DEBUG</pre>

        <h4 id="console-logging">Console Logging</h4>

        <p>
            By default, Dropwizard services log <code>INFO</code> and higher to <code>STDOUT</code>.
            You can configure this by editing the <code>logging</code> section of your YAML
            configuration file:
        </p>

        <pre class="prettyprint lang-yaml">
logging:
  # ...
  # Settings for logging to stdout.
  console:
    # If true, write log statements to stdout.
    enabled: true
    # Do not display log statements below this threshold to stdout.
    threshold: ALL</pre>

        <h4 id="file-logging">File Logging</h4>

        <p>
            Dropwizard can also log to an automatically rotated set of log files. This is the
            recommended configuration for your production environment:
        </p>

        <pre class="prettyprint lang-yaml">
logging:
  # ...
  # Settings for logging to a file.
  file:
    # If true, write log statements to a file.
    enabled: false
    # Do not write log statements below this threshold to the file.
    threshold: ALL
    # The file to which statements will be logged. When the log file reaches the maximum size, the
    # file will be renamed example.log.1, example.log will be truncated, and new statements written
    # to it.
    filenamePattern: ./logs/example.log
    # The maximum size of any log file. Can also be "1GiB" etc
    maxFileSize: 50MB
    # The maximum number of log files to retain.
    retainedFileCount: 5</pre>

        <h4 id="syslog-logging">Syslog Logging</h4>

        <p>
            Finally, Dropwizard can also log statements to syslog. (<strong>Note:</strong> because
            Java doesn’t use the native syslog bindings, your syslog server <strong>must</strong>
            have an open network socket.)
        </p>

        <pre class="prettyprint lang-yaml">
logging:
  # ...
  # Settings for logging to syslog.
  syslog:
    # If true, write log statements to syslog.
    enabled: false
    # The hostname of the syslog server to which statements will be sent.
    # N.B.: If this is the local host, the local syslog instance will need to be configured to
    # listen on an inet socket, not just a Unix socket.
    host: localhost
    # The syslog facility to which statements will be sent.
    facility: local0
        </pre>

        <h3 id="testing-services">Testing Services</h3>

        <p>
            All of Dropwizard’s APIs are designed with testability in mind, so even your services
            can have unit tests:
        </p>

        <pre class="prettyprint lang-java">
public class MyServiceTest {
    private final Environment environment = mock(Environment.class);
    private final MyService service = new MyService();
    private final MyConfiguration config = new MyConfiguration();

    @Before
    public void setup() throws Exception {
        config.setMyParam("yay");
    }

    @Test
    public void buildsAThingResource() throws Exception {
        service.initialize(config, environment);

        verify(environment).addResource(any(ThingResource.class));
    }
}</pre>

        <p>
            We highly recommend
            <a href="http://code.google.com/p/mockito/" target="_blank">Mockito</a> for all your
            mocking needs.
        </p>

        <h3 id="banners">Banners</h3>

        <p>
            At Yammer, each of our services prints out a big ASCII art banner on startup. Yours
            should, too. It’s fun. Just add a <code>banner.txt</code> class to
            <code>src/main/resources</code> and it’ll print it out when your service starts:
        </p>

        <pre class="uglyprint">
INFO  [2011-12-09 21:56:37,209] com.yammer.dropwizard.cli.ServerCommand: Starting hello-world
INFO  [2011-12-09 21:56:37,214] com.yammer.dropwizard.cli.ServerCommand:
                                                 dP
                                                 88
  .d8888b. dP.  .dP .d8888b. 88d8b.d8b. 88d888b. 88 .d8888b.
  88ooood8  `8bd8'  88'  `88 88'`88'`88 88'  `88 88 88ooood8
  88.  ...  .d88b.  88.  .88 88  88  88 88.  .88 88 88.  ...
  `88888P' dP'  `dP `88888P8 dP  dP  dP 88Y888P' dP `88888P'
                                        88
                                        dP

INFO  [2011-12-09 21:56:37,214] org.eclipse.jetty.server.Server: jetty-7.6.0.RC1
...</pre>

        <p>
            We could probably make up an argument about why this is a serious devops best practice
            with high ROI and an Agile Tool, but honestly we just enjoy this.
        </p>

        <h2 id="resources">Resources</h2>

        <p>
            Unsurprisingly, most of your day-to-day work with a Dropwizard service will be in the
            resource classes, which model the resources exposed in your RESTful API. Dropwizard
            uses <a href="http://jersey.java.net/" target="_blank">Jersey</a> for this, so most of
            this section is just re-hashing or collecting various bits of Jersey documentation.
        </p>

        <p>
            Jersey is a framework for mapping various aspects of incoming HTTP requests to POJOs and
            then mapping various aspects of POJOs to outgoing HTTP responses. Here’s a basic
            resource class:
        </p>

        <pre id="resource-example" class="prettyprint lang-java">
@Path("/{user}/notifications")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class NotificationsResource {
    private final NotificationStore store;

    public NotificationsResource(NotificationStore store) {
        this.store = store;
    }

    @GET
    public NotificationList fetch(@PathParam("user") LongParam userId,
                                  @QueryParam("count") @DefaultValue("20") IntParam count) {
        final List&lt;Notification&gt; notifications = store.fetch(userId.get(), count.get());
        if (notifications != null) {
            return new NotificationList(userId, notifications);
        }
        throw new WebApplicationException(Status.NOT_FOUND);
    }

    @POST
    public Response add(@PathParam("user") LongParam userId,
                        @Valid Notification notification) {
        final long id = store.add(userId.get(), notification);
        return Response.created(UriBuilder.fromResource(NotificationResource.class)
                                          .build(userId.get(), id)
                       .build();
    }
}</pre>

        <p>
            This class provides a resource (a user’s list of notifications) which responds to
            <code>GET</code> and <code>POST</code> requests to <code>/{user}/notifications</code>,
            providing and consuming <code>application/json</code> representations. There’s quite a
            lot of functionality on display here, and this section will explain in detail what’s
            in play and how to use these features in your service.
        </p>

        <h3 id="paths">Paths</h3>

        <p>
            <strong>Every resource class must have a <code>@Path</code> annotation.</strong> The
            <code>@Path</code> annotation isn’t just a static string, it's a
            <a href="http://tools.ietf.org/html/draft-gregorio-uritemplate-07" target="_blank">URI Template</a>.
            The <code>{user}</code> part denotes a named variable, and when the template matches a
            URI the value of that variable will be accessible via <code>@PathParam</code>-annotated
            method parameters.
        </p>

        <p>
            For example, an incoming request for <code>/1001/notifications</code> would match the
            URI template, and the value <code>1001</code> would be available as the path parameter
            named <code>user</code>.
        </p>

        <p>
            If your service doesn’t have a resource class whose <code>@Path</code> URI template
            matches the URI of an incoming request, Jersey will automatically return a
            <code>404 Not Found</code> to the client.
        </p>
        
        <h3 id="methods">Methods</h3>
        
        <p>
            Methods on a resource class which accept incoming requests are annotated with the HTTP
            methods they handle: <code>@GET</code>, <code>@POST</code>, <code>@PUT</code>,
            <code>@DELETE</code>, <code>@HEAD</code>, <code>@OPTIONS</code>, and even
            <code>@HttpMethod</code> for arbitrary new methods.
        </p>
        
        <p>
            If a request comes in which matches a resource class’s path but has a method which the
            class doesn’t support, Jersey will automatically return a
            <code>405 Method Not Allowed</code> to the client.
        </p>

        <p>
            The return value of the method (in this case, a <code>NotificationList</code> instance)
            is then mapped to the <a href="#conneg">negotiated content type</a>. In this case, our
            resource only supports JSON, and so the <code>NotificationList</code> is serialized to
            JSON using Jackson.
        </p>

        <h3 id="parameters">Parameters</h3>

        <p>
            The annotated methods on a resource class can accept parameters which are mapped to from
            aspects of the incoming request. The <code>*Param</code> annotations determine which
            part of the request the data is mapped, and the parameter <em>type</em> determines how
            the data is mapped.
        </p>

        <p>
            For example:
        </p>

        <ul>
            <li>
                A <code>@PathParam("user")</code>-annotated <code>String</code> takes the raw value
                from the <code>user</code> variable in the matched URI template and passes it into
                the method as a <code>String</code>.
            </li>
            <li>
                A <code>@QueryParam("count")</code>-annotated <code>IntParam</code> parameter takes
                the first <code>count</code> value from the request’s query string and passes it as
                a <code>String</code> to <code>IntParam</code>’s constructor. <code>IntParam</code>
                (and all other <code>com.yammer.dropwizard.jersey.params.*</code> classes) parses
                the string as an <code>Integer</code>, returning a <code>400 Bad Request</code> if
                the value is malformed.
            </li>
            <li>
                A <code>@FormParam("name")</code>-annotated <code>Set&lt;String&gt;</code> parameter
                takes all the <code>name</code> values from a posted form and passes them to the
                method as a set of strings.
            </li>
        </ul>

        <p>
            What’s noteworthy here is that you can actually encapsulate the vast majority of your
            validation logic using specialized parameter objects. See <code>AbstractParam</code> for
            details.
        </p>

        <h3 id="request-entities">Request Entities</h3>
        
        <p>
            If you’re handling request entities (e.g., an <code>application/json</code> object on
            a <code>PUT</code> request), you can model this as a parameter without a
            <code>*Param</code> annotation. In the <a href="#resource-example">example code</a>,
            the <code>add</code> method provides a good example of this:
        </p>

        <pre class="prettyprint lang-java">
@POST
public Response add(@PathParam("user") LongParam userId,
                    @Valid Notification notification) {
    final long id = store.add(userId.get(), notification);
    return Response.created(UriBuilder.fromResource(NotificationResource.class)
                                      .build(userId.get(), id)
                   .build();
}</pre>

        <p>
            Jersey maps the request entity to any single, unbound parameter. In this case, because
            the resource is annotated with <code>@Consumes(MediaType.APPLICATION_JSON)</code>, it
            uses the Dropwizard-provided Jackson support which, in addition to parsing the JSON and
            mapping it to an instance of <code>Notification</code>, also runs it through
            Dropwizard’s <a href="#validation">validation</a>.
        </p>

        <p>
            If the deserialized <code>Notification</code> isn’t valid, Dropwizard returns a
            <code>422 Unprocessable Entity</code> response to the client.
        </p>

        <h3 id="conneg">Media Types</h3>

        <p>
            Jersey also provides full content negotiation, so if your resource class consumes
            <code>application/json</code> but the client sends a <code>text/plain</code> entity,
            Jersey will automatically reply with a <code>406 Not Acceptable</code>. Jersey’s even
            smart enough to use client-provided <code>q</code>-values in their <code>Accept</code>
            headers to pick the best response content type based on what both the client and server
            will support.
        </p>

        <h3 id="responses">Responses</h3>

        <p>
            If your clients are expecting custom headers or additional information (or, if you
            simply desire an additional degree of control over your responses), you can return
            explicitly-built <code>Response</code> objects:
        </p>

        <pre class="prettyprint lang-java">
return Response.noContent().language(Locale.GERMAN).build();</pre>

        <p>
            In general, though, we recommend you return actual domain objects if at all possible.
            It makes <a href="#testing-resources">testing resources</a> much easier.
        </p>
        
        <h3 id="error-handling">Error Handling</h3>

        <p>
            If your resource class unintentionally throws an exception, Dropwizard will log that
            exception (including stack traces) and return a terse, safe <code>500</code> response.
        </p>

        <p>
            If your resource class needs to return an error to the client (e.g., the requested
            record doesn’t exist), you have two options: throw a
            <code>WebApplicationException</code> or restructure your method to return a
            <code>Response</code>.
        </p>

        <p>
            If at all possible, prefer throwing <code>WebApplicationException</code> instances to
            returning <code>Response</code> objects.
        </p>
        
        <h3 id="uris">URIs</h3>

        <p>
            While Jersey doesn’t quite have first-class support for hyperlink-driven services, the
            provided <code>UriBuilder</code> functionality does quite well.
        </p>

        <p>
            Rather than duplicate resource URIs, it’s possible (and recommended!) to initialize a
            <code>UriBuilder</code> with the path from the resource class itself:
        </p>

        <pre class="prettyprint lang-java">
UriBuilder.fromResource(UserResource.class).build(user.getId());</pre>
        
        <h3 id="testing-resources">Testing</h3>

        <p>
            As with just about everything in Dropwizard, we recommend you design your resources to
            be testable. Dependencies which aren’t request-injected should be passed in via the
            constructor and assigned to <code>final</code> fields.
        </p>

        <p>
            Testing, then, consists of creating an instance of your resource class and passing it
            a mock. (Again: <a href="http://code.google.com/p/mockito/" target="_blank">Mockito</a>.)
        </p>

        <pre class="prettyprint lang-java">
public class NotificationsResourceTest {
    private final NotificationStore store = mock(NotificationStore.class);
    private final NotificationsResource resource = new NotificationsResource(store);

    @Test
    public void getsReturnNotifications() {
        final List&lt;Notification&gt; notifications = mock(List.class);
        when(store.fetch(1, 20)).thenReturn(notifications);

        final NotificationList list = resource.fetch(new LongParam("1"), new IntParam("20"));

        assertThat(list.getUserId(),
                  is(1L));

        assertThat(list.getNotifications(),
                   is(notifications));
    }
}</pre>
        
        <h3 id="oauth">OAuth2</h3>

        <p>
            Dropwizard provides some super-minimalist support for
            <a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-22" target="_blank">Oauth 2</a>:
        </p>

        <pre class="prettyprint lang-java">
public Blah doAThing(@BearerToken String token) {
    // etc
}</pre>

        <p>
            The Oauth 2 bearer token will be passed in via <code>token</code>.
        </p>

        <h2 id="representations">Representations</h2>

        <p>
            Representation classes are classes which, when handled to various Jersey
            <code>MessageBodyReader</code> and <code>MessageBodyWriter</code> providers, become the
            entities in your service’s API. Dropwizard heavily favors JSON, but it’s possible to
            map from any POJO to custom formats and back.
        </p>
        
        <h3 id="json">Basic JSON</h3>

        <p>
            Jackson is awesome at converting regular POJOs to JSON and back. This file:
        </p>

        <pre class="prettyprint lang-java">
public class Notification {
    @JsonProperty
    private String text;

    public Notification(String text) {
        this.text = text;
    }

    public String getText() {
        return text;
    }

    public String setText(String text) {
        this.text = text;
    }
}</pre>

        <p>
            gets converted into this JSON:
        </p>
        
        <pre class="prettyprint lang-json">
{
    "text": "hey it's the value of the text field"
}</pre>

        <p>
            If, at some point, you need to change the JSON field name or the Java field without
            affecting the other, you can add an explicit field name to the
            <code>@JsonProperty</code> annotation.
        </p>

        <p>
            If you prefer immutable objects rather than JavaBeans, that’s also doable:
        </p>

        <pre class="prettyprint lang-java">
public class Notification {
    @JsonProperty
    private final String text;

    public Notification(@JsonProperty("text") String text) {
        this.text = text;
    }

    public String getText() {
        return text;
    }
}</pre>
        
        <h3 id="advanced-json">Advanced JSON</h3>

        <p>
            Not all JSON representations map nicely to the objects your service deals with, so it’s
            sometimes necessary to use custom serializers and deserializers. Just annotate your
            object like this:
        </p>

        <pre class="prettyprint lang-java">
@JsonSerialize(using=FunkySerializer.class)
@JsonDeserialize(using=FunkyDeserializer.class)
public class Funky {
    // ...
}</pre>

        <p>
            Then make a <code>FunkySerializer</code> class which implements
            <code>JsonSerializer&lt;Funky&gt;</code> and a <code>FunkyDeserializer</code> class
            which implements <code>JsonDeserializer&lt;Funky&gt;</code>.
        </p>

        <h4 id="snakecase">snake_case</h4>

        <p>
            A common issue with JSON is the disagreement between <code>camelCase</code> and
            <code>snake_case</code> field names. Java and Javascript folks tend to like
            <code>camelCase</code>; Ruby, Python, and Perl folks insist on <code>snake_case</code>.
            To make Dropwizard automatically convert field names to <code>snake_case</code> (and
            back), just annotate the class with <code>@JsonSnakeCase</code>:
        </p>



        <pre class="prettyprint lang-java">
@JsonSnakeCase
public class Person {
    @JsonProperty
    private String firstName;

    public Person(String firstName) {
        this.firstName = firstName;
    }

    public String getFirstName() {
        return firstName;
    }
}</pre>

        <p>
            gets converted into this JSON:
        </p>

        <pre class="prettyprint lang-json">
{
    "first_name": "Coda"
}</pre>

        <h3 id="validation">Validation</h3>

        <p>
            Like <a href="#configuration">configuration classes</a>, you can add validation
            annotations to fields of your representation classes and validate them. If we‘re
            accepting client-provided <code>Person</code> objects, we probably want to ensure that
            the <code>name</code> field of the object isn’t <code>null</code> or blank. We can do
            this as follows:
        </p>

        <pre class="prettyprint lang-java">
public class Person {
    @NotEmpty // ensure that name isn't null or blank
    @JsonProperty
    private final String name;

    public Person(@JsonProperty("name") String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}</pre>

        <p>
            Then, in our resource class, we can add the <code>@Valid</code> annotation to the
            <code>Person</code> annotation:
        </p>

        <pre class="prettyprint lang-java">
@PUT
public Response replace(@Valid Person person) {
    // ...
}</pre>

        <p>
            If the <code>name</code> field is missing, Dropwizard will return a
            <code>text/plain</code> <code>422 Unprocessable Entity</code> response detailing the
            validation errors:
        </p>

        <pre class="uglyprint">
* name may not be empty</pre>
        
        <h4 id="advanced-validation">Advanced</h4>

        <p>
            More complex validations (for example, cross-field comparisons) are often hard to
            do using declarative annotations. As an emergency maneuver, add the
            <code>@ValidationMethod</code> to any <code>boolean</code>-returning method which
            begins with <code>is</code>:
        </p>

        <pre class="prettyprint lang-java">
@ValidationMethod(message="may not be Coda")
public boolean isNotCoda() {
    return !("Coda".equals(name));
}</pre>

        <p>
            Due to the rather daft JavaBeans conventions, <strong>the method must begin with
            <code><strong>is</strong></code></strong>. This is a limitation of Hibernate Validator,
            not Dropwizard.
        </p>
        
        <h3 id="streaming">Streaming Output</h3>

        <p>
            If your service happens to return lots of information, you may get a big performance
            and efficiency bump by using streaming output. By returning an object which implements
            Jersey’s <code>StreamingOutput</code> interface, your method can stream the response
            entity in a chunk-encoded output stream. Otherwise, you’ll need to fully construct your
            return value and <em>then</em> hand it off to be sent to the client.
        </p>
        
        <h3 id="testing-representations">Testing</h3>

        <p>
            The <code>dropwizard-testing</code> module contains a number of helper methods for
            testing JSON parsing and generating. Given a JSON fixture file (e.g.,
            <code>src/test/resources/fixtures/person.json</code>), you can test that a
            <code>Person</code> instance generates the same JSON as the fixture with the following:
        </p>

        <pre class="prettyprint lang-java">
import static com.yammer.dropwizard.testing.JsonHelpers.asJson;
import static com.yammer.dropwizard.testing.JsonHelpers.jsonFixture;

@Test
public void producesTheExpectedJson() throws Exception {
    assertThat("rendering a person as JSON produces a valid API representation",
               asJson(person),
               is(jsonFixture("fixtures/person.json")));
}</pre>

        <p>
            This does a whitespace- and comment-insensitive comparison of the generated JSON and the
            JSON in the file. If they’re different, both JSON representations are helpfully
            displayed in the assertion error.
        </p>
        
        <p>
            Likewise, you can also test the parsing of the same JSON file to guarantee round-trip
            compatibility:
        </p>

        <pre class="prettyprint lang-java">
import static com.yammer.dropwizard.testing.JsonHelpers.fromJson;

@Test
public void consumesTheExpectedJson() throws Exception {
    assertThat("parsing a valid API representation produces a person",
               fromJson(jsonFixture("fixtures/person.json"), Person.class),
               is(person));
}</pre>
        
        <h3 id="custom-representations">Custom Representations</h3>

        <p>
            Sometimes, though, you’ve got some wacky output format you need to produce or consume
            and no amount of arguing will make JSON acceptable. That’s unfortunate but OK. You can
            add support for arbitrary input and output formats by creating classes which implement
            Jersey’s <code>MessageBodyReader&lt;T&gt;</code> and
            <code>MessageBodyWriter&lt;T&gt;</code> interfaces. (Make sure they’re annotated with
            <code>@Provider</code> and <code>@Produces("text/gibberish")</code> or
            <code>@Consumes("text/gibberish")</code>.) Once you’re done, just add instances of them
            (or their classes if they depend on Jersey’s <code>@Context</code> injection) with your
            service’s <code>Environment</code> on initialization.
        </p>

        <h2 id="running">Running Services</h2>

        <p>TODO</p>

        <h2 id="production">In Production</h2>

        <p>TODO</p>

        <h2 id="client">Dropwizard Client</h2>

        <p>TODO</p>

        <h2 id="db">Dropwizard DB</h2>

        <p>TODO</p>

        <h2 id="templates">Dropwizard Templates</h2>

        <p>TODO</p>

        <h2 id="scala">Dropwizard &amp; Scala</h2>

        <p>TODO</p>

        <footer>
            <p>&copy; Yammer 2011</p>
        </footer>
    </div>
</div>

</body>
</html>
